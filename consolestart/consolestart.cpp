#pragma once // выполняет функию единожды (ускорила в 2 раза)
#include<iostream>
using namespace std;
#define N 8
#define MAX N*N
#define MaxWayNumber 8
struct point{//структура точки определения
	int x;
	int y;
	int director;
};


class Stack
{
public:
	Stack();

	void initialStack();//Инициализация стека
	void throwstack(int x, int y);//закинуть  стопку
	void failedstack();//Стопка отказов
	void startpoint(int x, int y);//Начальная координатная точка
	int findWay(int x, int y);//Найти путь
	void numberWay(int x, int y);//Количество позиций, которые можно занять после следующего шага, отсортирует от малого к большому и сохранит индекс
	void displayWay();//Путь 
	int startDFS();//Начало решения DFS
	void DFS(int x, int y);//DFS решение
	void displayDFSway();//Принт DFS решения

	virtual ~Stack();
private:
	int top;//Верхний порог
	int DB[N][N];//Шахматная доска 
	point step[MAX];//Массив точек количество шагов прыжка лошади,(используется для входа в стек и выхода из него)
};
#include<iomanip> // 
Stack::Stack()
{
	initialStack();
}

void Stack::initialStack()
{
	top = -1;
	int i, j;
	for (i = 0; i < N; i++)
		for (j = 0; j < N; j++)
			DB[i][j] = 0;//Отметить доску как не идущую
}

void Stack::throwstack(int x, int y)
{
	top++;
	step[top].x = x;//Координаты складываются в стопку
	step[top].y = y;
	step[top].director = -1;//Начальное направление
	DB[x][y] = top + 1;//Отмечаем порядок ходов на доске
}

void Stack::failedstack()//Стопка отказов
{
	DB[step[top].x][step[top].y] = 0;//Очистите отметку 
	top--;
}

void Stack::startpoint(int x, int y)//Начальные координаты
{
	throwstack(x, y);//Исходная позиция помещается в стопку
	if (findWay(x, y))
		displayWay();//Путь печати
	else
		cout << "The path does not exist." << endl;

}
const int jumpx[8] = { 1,2,2,1,-1,-2,-2,-1 };//Увеличим массив горизонтальных и вертикальных координат лошади
const int jumpy[8] = { -2,-1,1,2,2,1,-1,-2 }; // Увеличим массив горизонтальных и вертикальных координат лошади
int num[8];//Количество подвижных позиций в направлении лошади 0-7 упорядочено от малого к большому, а нижний индекс сохраняется в массиве num[8].
const int PositionNum[8][8] = {
		{2,3,4,4,4,4,3,2},
		{3,4,6,6,6,6,4,3},
		{4,6,8,8,8,8,6,4},
		{4,6,8,8,8,8,6,4},
		{3,4,6,6,6,6,4,3},
		{2,3,4,4,4,4,3,2}
};//Количество путей, которые можут пройти  клетка на шахматной доске 

int Stack::findWay(int x, int y)//поиск прохода
{
	int i = 0;
	int tempx, tempy, director, find;//Временные координаты, направление, нужно ли находить местоположение
	while (top > -1)//Стек не пуст и повторно находит путь
	{
		numberWay(step[top].x, step[top].y);//Находим наименьший путь от вершины стека
		director = step[top].director;//Считаем текущее направление верхней части стека
		for (i = director + 1; i < 8; i++)
		{
			find = 0;
			tempx = step[top].x + jumpx[num[i]];//Обновили координаты,  выбрали позицию с несколькими путями (ядро жадного алгоритма)
			tempy = step[top].y + jumpy[num[i]];
			step[top].director = i;//Сохраняем текущее направление ходьбы
			if (DB[tempx][tempy] == 0 && tempx >= 0 && tempx < N && tempy >= 0 && tempy < N)//Следующая позиция может перейти
			{
				find = 1;//Находм следующую позицию
				break;//Нашли, вышли из цикла и сохранили текущее направление
			}
		}
		if (find)
			throwstack(tempx, tempy);//Нажмите на стек, когда найдете следующий шаг
		else
			failedstack();
		if (top >= N * N - 1)//В стеке 64 координаты (пройдитесь по всей доске)
			return 1;
	}
	return 0;
}

int a[8];//Сохраняем количество путей в следующей позиции в 8 направлениях
int nextx[8], nexty[8];//Сохраняем временный массив из 8 координат направления следующей позиции
void Stack::numberWay(int x, int y)//основная часть, найдите лучшую позицию и сохраните индекс в number.	
{
	int i, j;
	int min, max;//Индекс с наименьшим путем записи
	int nowx, nowy, number;//Временные координаты, количество путей
	for (i = 0; i < 8; i++){
		number = 0;//Обратный отсчет до 0
		nowx = step[top].x + jumpx[i];//Обновляем координаты следующего положения 8 координат направления
		nowy = step[top].y + jumpy[i];
		nextx[i] = nowx;//Сохраняем координаты следующей позиции 
		nexty[i] = nowy;
		if (DB[nowx][nowy] == 0 && nowx >= 0 && nowx < N && nowy >= 0 && nowy < N)//Находим следующий путь 
		{
			for (j = 0; j < 8; j++){
				nowx = nextx[i] + jumpx[j];//Координаты следующей позиции скачут в 8 направлениях
				nowy = nexty[i] + jumpy[j];
				if (DB[nowx][nowy] == 0 && nowx >= 0 && nowx < N && nowy >= 0 && nowy < N)//Следующий шаг доступен
					number++;//Количество увеличивается на 1, если есть способ
			}
			a[i] = number;//количество путей направления сохраняется в массиве a
		}
	}
	for (i = 0; i < 8; i++) //Количество путей, которые можно использовать, сортируется от малого к большому. Индексы хранятся в массиве num
	{
		min = 9;
		max = i;//Запишем нижний индекс текущего минимального значения
		for (j = 0; j < 8; j++){
			if (min > a[j]){ // находим мин кол-во ходов
				min = a[j];//Обновляем минимальное значение
				num[i] = j; //Сохранияем индекс в массиве num
			}
			a[max] = 9;//Пусть данные с минимальным значением станут 9 
		}
	}
}

void Stack::displayWay()//Выведим путь на доске
{
	int i, j;
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < N; j++)
			cout << setw(5) << DB[i][j];// для красивого вывода доски
		cout << endl << endl;
	}
}
int Stack::startDFS()
{
	int x, y;
	x = y = 0;
	DB[x][y] = 1;
	DFS(x, y);
	return 0;
}
extern int stepcount = 1;
extern int WayNumber = 1;
void Stack::DFS(int x, int y)//Решение DFS
{
	int i, a, b;//Временные координаты a, b
	for (i = 0; i < N; i++)
	{
		a = x + jumpx[i];//Переместитесь в следующую позицию и дайте координаты a, b
		b = y + jumpy[i];
		if (a >= 0 && a < N && b >= 0 && b < N && !DB[a][b])//на шахматной доске
		{
			DB[a][b] = ++stepcount;//Отмечаем шахматную доску
			if (stepcount < 64)//Все еще есть место, продолжаем рекурсивно выполнять обход DFS
			{
				if (WayNumber <= MaxWayNumber)
					DFS(a, b);
			}
			else//Все шахматные доски помечены
			{
				displayDFSway();//Распечатаем решение DFS и завершим работу
			}
			DB[a][b] = 0;//Сняли отметку для выхода
			stepcount--; //Вычли и "вышли" из себя
		}
	}
}
void Stack::displayDFSway()
{
	int i, j;
	DB[0][0] = 1;
	cout << " " << WayNumber++ << " The solution is: " << endl;
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < N; j++)
			cout << setw(5) << DB[i][j];
		cout << endl << endl;
	}
}
Stack::~Stack()
{
	initialStack();
}
// После всех подготовительыных работ собираем главную функцию;) 
// *************************************************************************************************************************************************************************
// *************************************************************************************************************************************************************************
// *************************************************************************************************************************************************************************
// *************************************************************************************************************************************************************************
// *************************************************************************************************************************************************************************
// *************************************************************************************************************************************************************************
// *************************************************************************************************************************************************************************
// *************************************************************************************************************************************************************************
// *************************************************************************************************************************************************************************


#include"ctime"// таймер 
#include <iostream>
using namespace std;
#define N 8
int main(){
	
	int x, y; 
	Stack Horse;
	int contral = 1;//Продожить или нет
	clock_t startTime, endTime;//Время
	double time;

	while (contral){
		bool a = 0;
		while (!a){
			cout << "input horse coordinates(1 <= x, y <= 8):" << endl;
			cout << "x = ";
			cin >> x;
			cout << "y = ";
			cin >> y;
			a = (x >= 1 && x <= N && y >= 1 && y <= N);//Ограничение координат
			if (a) {
				cout << "We  started from the point(" << x << ", " << y << ")" << endl;
				startTime = clock();//Начинается отсчет времени
				Horse.startpoint(x - 1, y - 1);//Начальная точка, чтобы найти способ
				endTime = clock();//Конец отсчета времени
			}
			else
				cout << "The input position is (" << x << "," << y << "), please input again if the position is wrong." << endl;
		}
		Horse.initialStack();//Пустая доска
		time = (double)(endTime - startTime) / CLOCKS_PER_SEC;//рассчитываем время
		cout << "The time used in finding way is: " << time << "s" << endl;
		cout << "************ 1 - for continue or 0 - for exit.*******************" << endl;
		
		cin >> contral;
	}
	return 0;
}